<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Cliente | Ramallo Taxi Tracker</title>
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  <link rel="shortcut icon" href="/favicon.ico" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
  <style>
    body { background: #0b0b0c; color: #fff; }
    .bg-dark { background: #000 !important; }
    .navbar { background: #000 !important; }
    
    /* üéØ FIX: Animaci√≥n para notificaci√≥n */
    @keyframes pulse {
      0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
      50% { transform: translate(-50%, -50%) scale(1.05); }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }
    /* üéØ FIX: Mapa FULLSCREEN siempre */
    #map { 
      height: calc(100vh - 56px) !important; /* 56px = altura navbar */
      width: 100% !important;
    }
    body.ride-mode #map { height: 100vh !important; }
    body.ride-mode .navbar { display: none; }
    /* üéØ ETA GRANDE y PREMIUM */
    #navPill {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1500;
      background: linear-gradient(135deg, #000 0%, #1f1f1f 100%);
      color: #fff;
      padding: 20px 32px;
      border-radius: 20px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
      backdrop-filter: blur(10px);
      animation: slideDown 0.5s ease-out;
    }
    
    @keyframes slideDown {
      from { opacity: 0; transform: translate(-50%, -30px); }
      to { opacity: 1; transform: translate(-50%, 0); }
    }
    
    #etaBadge {
      font-size: 36px;
      font-weight: 800;
      color: #4ade80;
      text-shadow: 0 2px 8px rgba(74, 222, 128, 0.3);
    }
    
    /* Timeline del viaje */
    .trip-timeline {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.9);
      backdrop-filter: blur(10px);
      padding: 16px 24px;
      border-radius: 16px;
      z-index: 1500;
      display: flex;
      gap: 24px;
      align-items: center;
    }
    
    .timeline-step {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }
    
    .timeline-icon {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(255,255,255,0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
    }
    
    .timeline-icon.active {
      background: #4ade80;
      box-shadow: 0 0 20px rgba(74, 222, 128, 0.5);
      animation: pulse 2s infinite;
    }
    
    .timeline-label {
      font-size: 11px;
      color: rgba(255,255,255,0.7);
      font-weight: 600;
    }
    .arrow {
      width: 0;
      height: 0;
      border-left: 10px solid transparent;
      border-right: 10px solid transparent;
      border-bottom: 18px solid #0d6efd;
      filter: drop-shadow(0 0 2px rgba(0,0,0,.4));
    }
  </style>
  
  </head>
  <body>
  <div id="waitingBanner" class="alert alert-warning text-center m-0 d-none" role="alert">
    <i class="bi bi-hourglass-split me-1"></i> Esperando que un conductor acepte tu viaje‚Ä¶
  </div>
  <div id="assignedBanner" class="alert alert-success text-center m-0 d-none" role="alert">
    <i class="bi bi-check-circle-fill me-1"></i> <strong id="driverName">Conductor</strong> acept√≥ tu viaje. <span id="etaInfo">Siguiendo en tiempo real...</span>
  </div>
  <div id="arrivedBanner" class="alert alert-warning text-center m-0 d-none" role="alert">
    <i class="bi bi-geo-fill me-1"></i> ¬°Tu conductor <strong id="arrivedDriverName">lleg√≥</strong> al punto de partida!
  </div>
  <div id="completedOverlay" class="d-none position-fixed top-0 start-0 w-100 h-100" style="z-index: 1999; background: rgba(0,0,0,0.7);">
    <div class="alert alert-light text-center m-0 position-absolute top-50 start-50 translate-middle shadow-lg" role="alert" style="min-width: 340px; max-width: 90vw; border: 3px solid #28a745;">
      <h4 class="mb-3"><i class="bi bi-check-circle-fill text-success me-2"></i>Viaje Completado</h4>
      <p class="fs-5 mb-3">Gracias por viajar con nosotros</p>
      <div class="mb-3">
        <div class="small text-secondary">Total estimado</div>
        <div class="fs-3 fw-bold text-success">$<span id="fareAmount">---</span></div>
      </div>
      <button id="btnCloseFare" class="btn btn-success btn-lg w-100">Cerrar y Volver</button>
    </div>
  </div>

  <nav class="navbar navbar-expand-lg bg-white border-bottom">
    <div class="container-fluid">
      <a class="navbar-brand" href="/"><i class="bi bi-taxi-front-fill text-warning me-2"></i>Cliente</a>
      <div class="d-flex align-items-center gap-2 flex-wrap">
        <div class="input-group" id="driverGroup">
          <span class="input-group-text"><i class="bi bi-hash"></i></span>
          <input id="driverId" class="form-control" placeholder="ej: taxi-ramallo-1" style="min-width:160px" />
        </div>
        <button id="connectBtn" class="btn btn-primary">Conectar</button>
        <button id="centerBtn" class="btn btn-outline-primary d-none" disabled>Centrar</button>
        <button id="myLocBtn" class="btn btn-success btn-lg"><i class="bi bi-geo-alt-fill me-1"></i>Compartir mi ubicaci√≥n</button>
        <!-- --- NUEVA FUNCI√ìN DE SEGURIDAD: Bot√≥n alerta cliente --- -->
        <button id="btnClientAlert" class="btn btn-danger btn-lg d-none"><i class="bi bi-shield-exclamation me-1"></i>Alerta de Seguridad</button>
        <button id="enableClientPush" class="btn btn-outline-primary d-none">Habilitar notificaciones</button>
        <div class="vr d-none d-md-block"></div>
        <div class="input-group adv" style="width: 160px;">
          <span class="input-group-text">Cap(m)</span>
          <input id="accCap" type="number" class="form-control" value="150" min="0" step="10" />
        </div>
        <div class="input-group adv" style="width: 160px;">
          <span class="input-group-text">Trail</span>
          <input id="maxPts" type="number" class="form-control" value="200" min="10" step="10" />
        </div>
        <div class="form-check adv">
          <input id="showTrail" class="form-check-input" type="checkbox" checked />
          <label class="form-check-label">Mostrar recorrido</label>
        </div>
        <button id="clearTrail" class="btn btn-outline-secondary adv"><i class="bi bi-eraser"></i></button>
        <span id="driverStatus" class="badge text-bg-secondary">offline</span>
        <span id="driversCount" class="badge text-bg-primary fs-5 px-3 py-2 d-none">0 choferes cerca</span>
        <span class="badge text-bg-info" id="rideStatus" style="display:none;">-</span>
        <span class="badge text-bg-light text-dark" id="etaBadge" style="display:none;"><i class="bi bi-clock"></i> ETA: --</span>
      </div>
    </div>
  </nav>

  <div id="map"></div>
  
  <!-- üìä BARRA DE PROGRESO DEL VIAJE -->
  <div id="progressBar" style="display: none; position: fixed; top: 0; left: 0; right: 0; height: 4px; background: rgba(255,255,255,0.2); z-index: 2000;">
    <div id="progressFill" style="height: 100%; width: 0%; background: linear-gradient(90deg, #10b981 0%, #3b82f6 100%); transition: width 0.5s ease-out; box-shadow: 0 0 10px rgba(16, 185, 129, 0.5);"></div>
  </div>
  
  <!-- üë§ INFO DEL CONDUCTOR -->
  <div id="driverInfoCard" style="display: none; position: fixed; top: 80px; left: 50%; transform: translateX(-50%); z-index: 1500; background: #fff; border-radius: 20px; padding: 24px; box-shadow: 0 8px 32px rgba(0,0,0,0.2); min-width: 320px; animation: slideDown 0.5s;">
    <div style="display: flex; align-items: center; gap: 16px; margin-bottom: 16px;">
      <div style="width: 64px; height: 64px; border-radius: 50%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: flex; align-items: center; justify-content: center; font-size: 32px;">
        üöï
      </div>
      <div style="flex: 1;">
        <div style="font-size: 20px; font-weight: 800;" id="driverInfoName">Juan P√©rez</div>
        <div style="font-size: 14px; color: #666; display: flex; align-items: center; gap: 8px;">
          <span id="driverInfoRating">‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</span>
          <span style="opacity: 0.6;">(4.8)</span>
        </div>
      </div>
    </div>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; font-size: 14px;">
      <div style="text-align: center; padding: 12px; background: #f9fafb; border-radius: 12px;">
        <div style="font-weight: 700; color: #10b981;" id="driverInfoTrips">250</div>
        <div style="color: #666; font-size: 12px;">Viajes</div>
      </div>
      <div style="text-align: center; padding: 12px; background: #f9fafb; border-radius: 12px;">
        <div style="font-weight: 700; color: #3b82f6;" id="driverInfoCar">Ford Focus</div>
        <div style="color: #666; font-size: 12px;" id="driverInfoPlate">ABC-123</div>
      </div>
    </div>
  </div>
  
  <!-- üéØ ETA GRANDE PREMIUM -->
  <div id="navPill" class="d-none">
    <div style="text-align: center;">
      <div id="etaBadge" style="margin-bottom: 8px;">...</div>
      <div id="navPillText" style="font-size: 14px; opacity: 0.8;">Calculando...</div>
      <button id="shareRideBtn" style="margin-top: 12px; padding: 8px 16px; background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: #fff; border-radius: 8px; cursor: pointer; font-size: 12px;">
        <i class="bi bi-share-fill me-1"></i>Compartir viaje
      </button>
    </div>
  </div>
  
  <!-- üí¨ CHAT FLOTANTE -->
  <div id="chatWidget" style="position: fixed; bottom: 20px; right: 20px; z-index: 2000; display: none;">
    <button id="chatToggle" style="width: 60px; height: 60px; border-radius: 50%; background: #10b981; border: none; box-shadow: 0 4px 12px rgba(16,185,129,0.4); cursor: pointer;">
      <i class="bi bi-chat-dots-fill" style="font-size: 24px; color: #fff;"></i>
    </button>
    
    <div id="chatBox" style="display: none; position: absolute; bottom: 80px; right: 0; width: 320px; max-height: 400px; background: #fff; border-radius: 16px; box-shadow: 0 8px 24px rgba(0,0,0,0.2); overflow: hidden;">
      <div style="background: #10b981; color: #fff; padding: 16px; font-weight: 700;">
        üí¨ Chat con conductor
      </div>
      <div id="chatMessages" style="height: 250px; overflow-y: auto; padding: 16px; background: #f9fafb;"></div>
      <div style="padding: 12px; border-top: 1px solid #e5e7eb; display: flex; gap: 8px;">
        <input type="text" id="chatInput" placeholder="Escribe un mensaje..." style="flex: 1; padding: 10px; border: 1px solid #e5e7eb; border-radius: 8px; outline: none;" />
        <button id="chatSend" style="padding: 10px 16px; background: #10b981; color: #fff; border: none; border-radius: 8px; cursor: pointer;">
          <i class="bi bi-send-fill"></i>
        </button>
      </div>
    </div>
  </div>
  
  <!-- üéØ TIMELINE DEL VIAJE -->
  <div class="trip-timeline d-none" id="tripTimeline">
    <div class="timeline-step">
      <div class="timeline-icon" id="icon-waiting">üîç</div>
      <div class="timeline-label">Buscando</div>
    </div>
    <div style="width: 40px; height: 2px; background: rgba(255,255,255,0.2);"></div>
    <div class="timeline-step">
      <div class="timeline-icon" id="icon-assigned">üöï</div>
      <div class="timeline-label">Asignado</div>
    </div>
    <div style="width: 40px; height: 2px; background: rgba(255,255,255,0.2);"></div>
    <div class="timeline-step">
      <div class="timeline-icon" id="icon-arriving">üõ£Ô∏è</div>
      <div class="timeline-label">En camino</div>
    </div>
    <div style="width: 40px; height: 2px; background: rgba(255,255,255,0.2);"></div>
    <div class="timeline-step">
      <div class="timeline-icon" id="icon-arrived">üìç</div>
      <div class="timeline-label">Lleg√≥</div>
    </div>
    <div style="width: 40px; height: 2px; background: rgba(255,255,255,0.2);"></div>
    <div class="timeline-step">
      <div class="timeline-icon" id="icon-completed">‚úì</div>
      <div class="timeline-label">Completado</div>
    </div>
  </div>

  <!-- Core Systems -->
  <script src="/config.js"></script>
  <script src="/auth.js"></script>
  <script src="/analytics.js"></script>
  <!-- UX Systems -->
  <script src="/toast.js"></script>
  <script src="/haptics.js"></script>
  <script src="/sounds.js"></script>
  <script src="/connection.js"></script>
  <script src="/theme.js"></script>
  <script src="/notifications.js"></script>
  <script src="/i18n.js"></script>
  <!-- Advanced Systems -->
  <script src="/socket-manager.js"></script>
  <script src="/socket.io/socket.io.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <script>
    const qs = new URLSearchParams(location.search);
    const driverIdInput = document.getElementById('driverId');
    driverIdInput.value = qs.get('driverId') || localStorage.getItem('driverId') || 'taxi-ramallo-1';
    const rideId = qs.get('rideId') || null;
    const connectBtn = document.getElementById('connectBtn');
    const driverGroup = document.getElementById('driverGroup');
    const centerBtn = document.getElementById('centerBtn');
    const myLocBtn = document.getElementById('myLocBtn');
    const enableClientPush = document.getElementById('enableClientPush');
    // --- NUEVA FUNCI√ìN DE SEGURIDAD ---
    const btnClientAlert = document.getElementById('btnClientAlert');
    const driverStatus = document.getElementById('driverStatus');
    const driversCount = document.getElementById('driversCount');
    const accCapInput = document.getElementById('accCap');
    const maxPtsInput = document.getElementById('maxPts');
    const showTrail = document.getElementById('showTrail');
    const clearTrailBtn = document.getElementById('clearTrail');
    const rideStatus = document.getElementById('rideStatus');
    const etaBadge = document.getElementById('etaBadge');

    const socket = io();
    let joinedRoom = null;
    let joinedRideRoom = null;
    let currentAssignedDriverId = null;

    // üéØ FIX: Leaflet map con inicializaci√≥n correcta
    const defaultCenter = [ -33.4847, -60.0062 ];
    const map = L.map('map', { 
      center: defaultCenter, 
      zoom: 13,
      zoomControl: true
    });
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap'
    }).addTo(map);
    
    // üéØ FIX: Forzar que el mapa se redibuje correctamente
    setTimeout(() => {
      map.invalidateSize();
      map.setView(defaultCenter, 13);
    }, 100);

    // Marker with heading arrow (divIcon)
    const arrowIcon = L.divIcon({ className: '', html: '<div class="arrow"></div>', iconSize: [20, 20], iconAnchor: [10, 10] });
    let marker = null; // L.Marker (driver)
    let circle = null; // L.Circle (accuracy)
    let path = L.polyline([], { color: '#0d6efd', weight: 4, opacity: 0.9 }).addTo(map);
    // pickup/dest and suggested route
    let pickupMarker = null;
    let destMarker = null;
    let routeLine = L.polyline([], { color: '#6c757d', weight: 3, opacity: 0.8, dashArray: '6 6' }).addTo(map);
    // Client own location
    let meMarker = null; let meCircle = null; let meWatchId = null;
    let lastDriverLatLng = null;
    // Drivers while waiting
    const driversLayer = L.layerGroup().addTo(map);
    let driversPoll = null;
    let isWaiting = false;

    // Local audio beeps (requires prior user interaction on some browsers)
    let audioCtx = null;
    function primeAudio() {
      try {
        if (!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') audioCtx.resume();
      } catch {}
    }
    document.addEventListener('touchstart', primeAudio, { once: true });
    document.addEventListener('click', primeAudio, { once: true });
    function beep(f, dur=0.12, vol=0.15, type='sine', delay=0) {
      try {
        primeAudio(); if (!audioCtx) return;
        const t0 = audioCtx.currentTime + delay;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type; osc.frequency.value = f;
        gain.gain.setValueAtTime(vol, t0);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(t0); osc.stop(t0 + dur);
      } catch {}
    }
    function playAssignedBeep() { beep(523,0.12); beep(659,0.12,0.15,'sine',0.18); try{ navigator.vibrate?.([200,100,200]); }catch{} }
    function playArrivedBeep() { beep(784,0.12); beep(988,0.12,0.15,'sine',0.18); try{ navigator.vibrate?.([250,120,250]); }catch{} }

    async function joinAsClient() {
      // If rideId present, fetch ride and follow its assigned driver
      if (rideId) {
        try {
          const res = await fetch(`/api/rides/${rideId}`);
          if (res.ok) {
            const ride = await res.json();
            socket.emit('join_ride', { rideId });
            joinedRideRoom = rideId;
            currentAssignedDriverId = ride.driverId || null;
            updateRideUi(ride);
            
            // üéØ FIX: Mostrar mapa con pickup/destino aunque no haya conductor
            if (ride.pickupCoord || ride.destCoord) {
              await updateRouteUi(ride.pickupCoord, ride.destCoord);
              
              // üéØ FIX: Centrar en pickup si no hay conductor todav√≠a
              if (!ride.driverId && ride.pickupCoord) {
                setTimeout(() => {
                  map.setView([ride.pickupCoord.lat, ride.pickupCoord.lng], 14);
                  map.invalidateSize();
                }, 200);
                
                // üéØ FIX: Mostrar taxis disponibles mientras espera
                startShowingNearbyDrivers();
              }
            }
            
            if (ride.driverId) {
              driverIdInput.value = ride.driverId;
              localStorage.setItem('driverId', ride.driverId);
              joinedRoom = ride.driverId;
              socket.emit('join', { role: 'client', driverId: ride.driverId });
            }
          }
        } catch {}
      } else {
        const driverId = driverIdInput.value.trim() || 'taxi-ramallo-1';
        localStorage.setItem('driverId', driverId);
        joinedRoom = driverId;
        socket.emit('join', { role: 'client', driverId });
      }
    }

    const waitingBanner = document.getElementById('waitingBanner');
    const assignedBanner = document.getElementById('assignedBanner');
    const arrivedBanner = document.getElementById('arrivedBanner');
    const arrivedDriverName = document.getElementById('arrivedDriverName');
    const completedOverlay = document.getElementById('completedOverlay');
    const fareAmount = document.getElementById('fareAmount');
    const btnCloseFare = document.getElementById('btnCloseFare');
    const driverNameEl = document.getElementById('driverName');
    const etaInfo = document.getElementById('etaInfo');
    const navPill = document.getElementById('navPill');
    const navPillText = document.getElementById('navPillText');
    const navShare = document.getElementById('navShare');
    const navCall = document.getElementById('navCall');

    // Prepare share link
    try { if (rideId) { const url = `${location.origin}/client.html?rideId=${rideId}`; navShare.href = `https://wa.me/?text=${encodeURIComponent('Segu√≠ tu rem√≠s: ' + url)}`; } } catch {}

    // Persist last ETA
    let lastEtaSec = null;
    let ridePhone = null;
    // --- NUEVA FUNCI√ìN DE SEGURIDAD: ETA din√°mico ---
    let lastEtaUpdate = 0;
    let currentPickupCoord = null;
    let currentDestCoord = null;
    let currentRideStatus = null;
    
    // üéØ FIX: Mostrar taxis disponibles mientras espera
    let nearbyDriversMarkers = [];
    let nearbyDriversInterval = null;
    
    async function showNearbyDrivers() {
      try {
        const res = await fetch('/api/drivers');
        const json = await res.json();
        if (!json.ok || !Array.isArray(json.drivers)) return;
        
        // Limpiar marcadores viejos
        nearbyDriversMarkers.forEach(m => map.removeLayer(m));
        nearbyDriversMarkers = [];
        
        // Crear √≠cono de taxi disponible
        const taxiIcon = L.divIcon({
          className: '',
          html: '<div style="font-size:24px;filter:drop-shadow(0 2px 4px rgba(0,0,0,0.3));">üöï</div>',
          iconSize: [24, 24],
          iconAnchor: [12, 12]
        });
        
        json.drivers.forEach(d => {
          if (!isFinite(d.lat) || !isFinite(d.lng)) return;
          const marker = L.marker([d.lat, d.lng], { 
            icon: taxiIcon, 
            title: `Taxi ${d.driverId}`,
            opacity: 0.7
          }).addTo(map);
          nearbyDriversMarkers.push(marker);
        });
        
        console.log(`üìç Mostrando ${nearbyDriversMarkers.length} taxis disponibles`);
      } catch (e) {
        console.warn('Error obteniendo taxis cercanos', e);
      }
    }
    
    function startShowingNearbyDrivers() {
      showNearbyDrivers();
      nearbyDriversInterval = setInterval(showNearbyDrivers, 5000);
    }
    
    function stopShowingNearbyDrivers() {
      if (nearbyDriversInterval) {
        clearInterval(nearbyDriversInterval);
        nearbyDriversInterval = null;
      }
      nearbyDriversMarkers.forEach(m => map.removeLayer(m));
      nearbyDriversMarkers = [];
    }

    // Debounced fit/zoom to avoid jitter
    let fitTimer = null;
    function fitDebounced(points, ontrip=false) {
      if (!Array.isArray(points) || points.length===0) return;
      clearTimeout(fitTimer);
      fitTimer = setTimeout(() => {
        try {
          if (points.length === 1) map.flyTo(points[0], 15, { animate: true, duration: 1 });
          else map.fitBounds(L.latLngBounds(points).pad(0.2));
        } catch {}
      }, ontrip ? 300 : 200);
    }

    btnCloseFare.addEventListener('click', () => {
      completedOverlay.classList.add('d-none');
      location.href = '/';
    });
    function updateRideUi(ride) {
      if (!ride) return;
      rideStatus.style.display = 'inline-block';
      rideStatus.textContent = ride.status || '-';
      
      // üéØ Actualizar timeline seg√∫n estado
      const timeline = document.getElementById('tripTimeline');
      if (ride.status) {
        timeline.classList.remove('d-none');
        
        // Resetear todos
        ['waiting', 'assigned', 'arriving', 'arrived', 'completed'].forEach(s => {
          document.getElementById(`icon-${s}`)?.classList.remove('active');
        });
        
        // Activar seg√∫n estado
        if (ride.status === 'waiting') {
          document.getElementById('icon-waiting')?.classList.add('active');
        } else if (ride.status === 'assigned') {
          document.getElementById('icon-assigned')?.classList.add('active');
        } else if (ride.status === 'arriving' || ride.status === 'ontrip') {
          document.getElementById('icon-arriving')?.classList.add('active');
        } else if (ride.status === 'arrived') {
          document.getElementById('icon-arrived')?.classList.add('active');
        } else if (ride.status === 'completed') {
          document.getElementById('icon-completed')?.classList.add('active');
        }
      }
      // --- NUEVA FUNCI√ìN DE SEGURIDAD: Track status y coords ---
      currentRideStatus = ride.status;
      if (ride.pickupCoord) currentPickupCoord = ride.pickupCoord;
      if (ride.destCoord) currentDestCoord = ride.destCoord;
      if (ride.etaSec != null) {
        // Actualizar ETA grande
        const navPill = document.getElementById('navPill');
        const etaBadgeLarge = navPill.querySelector('#etaBadge');
        const navPillText = document.getElementById('navPillText');
        const mins = Math.max(0, Math.round(ride.etaSec / 60));
        
        if (mins > 0) {
          etaBadgeLarge.textContent = `${mins} min`;
          navPillText.textContent = ride.status === 'ontrip' ? 'Llegando al destino' : 'Tu conductor est√° cerca';
          navPill.classList.remove('d-none');
          
          // üéØ Alerta visual si est√° MUY cerca (< 2 min)
          if (mins <= 2 && ride.status !== 'ontrip') {
            navPill.style.animation = 'pulse 1.5s infinite';
            navPill.style.background = 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';
            etaBadgeLarge.style.color = '#fff';
            navPillText.textContent = 'üî• ¬°Ya casi llega!';
          } else {
            navPill.style.animation = '';
            navPill.style.background = 'linear-gradient(135deg, #000 0%, #1f1f1f 100%)';
            etaBadgeLarge.style.color = '#4ade80';
          }
        }
        
        lastEtaSec = ride.etaSec;
      } else if (lastEtaSec != null) {
        etaBadge.style.display = 'inline-block';
        const mins = Math.max(0, Math.round(lastEtaSec / 60));
        etaBadge.innerHTML = `<i class=\"bi bi-clock\"></i> ETA: ${mins} min`;
      }
      const isWaiting = (ride.status === 'requested') && !currentAssignedDriverId;
      const isAssigned = currentAssignedDriverId && ['assigned','arriving'].includes(ride.status);
      const isArrived = ride.status === 'arrived';
      const isOnTrip = ride.status === 'ontrip';
      const isCompleted = ride.status === 'completed';
      
      // üéâ Feedback cuando conductor LLEGA (una sola vez)
      if (isArrived && !window.arrivedNotified) {
        window.arrivedNotified = true;
        window.toast?.success('üéØ ¬°Tu conductor lleg√≥!');
        window.sounds?.arrival();
        window.haptics?.arrival();
        window.notifications?.driverArrived({
          driverName: currentAssignedDriverId || 'Tu conductor'
        });
      }
      
      // üìä Actualizar barra de progreso
      const progressBar = document.getElementById('progressBar');
      const progressFill = document.getElementById('progressFill');
      const progressMap = {
        'requested': 0,
        'assigned': 25,
        'arriving': 50,
        'arrived': 75,
        'ontrip': 85,
        'completed': 100
      };
      
      if (ride.status && progressMap[ride.status] !== undefined) {
        progressBar.style.display = 'block';
        progressFill.style.width = progressMap[ride.status] + '%';
        
        // Cambiar color seg√∫n progreso
        if (progressMap[ride.status] === 100) {
          progressFill.style.background = 'linear-gradient(90deg, #10b981 0%, #10b981 100%)';
        }
      }
      
      // üë§ Mostrar info del conductor cuando acepta (primera vez)
      const driverInfoCard = document.getElementById('driverInfoCard');
      if (isAssigned && !driverInfoCard.dataset.shown) {
        document.getElementById('driverInfoName').textContent = currentAssignedDriverId;
        // Demo data (en producci√≥n vendr√≠a de backend)
        const stars = Math.floor(Math.random() * 2) + 4; // 4 o 5 estrellas
        document.getElementById('driverInfoRating').textContent = '‚≠ê'.repeat(stars);
        document.getElementById('driverInfoTrips').textContent = Math.floor(Math.random() * 500) + 100;
        
        driverInfoCard.style.display = 'block';
        driverInfoCard.dataset.shown = 'true';
        
        // üéâ Feedback cuando conductor acepta
        window.toast?.success('¬°Un conductor acept√≥ tu viaje!');
        window.sounds?.success();
        window.haptics?.success();
        window.notifications?.rideAccepted({
          driverName: currentAssignedDriverId,
          eta: 5 // estimado
        });
        
        // Ocultar despu√©s de 5 segundos
        setTimeout(() => {
          driverInfoCard.style.display = 'none';
        }, 5000);
      }
      
      // Show only one banner at a time (priority: completed > arrived > assigned > waiting)
      waitingBanner.classList.toggle('d-none', !isWaiting);
      assignedBanner.classList.toggle('d-none', !(isAssigned && !isArrived && !isOnTrip));
      arrivedBanner.classList.toggle('d-none', !(isArrived || isOnTrip));
      
      // Show/hide drivers count badge only while waiting
      driversCount.classList.toggle('d-none', !isWaiting);
      
      // Enter ride-mode (fullscreen map) as soon as there is a driver
      if ((isAssigned || isArrived || isOnTrip) && currentAssignedDriverId) {
        try { document.body.classList.add('ride-mode'); } catch {}
        // --- NUEVA FUNCI√ìN DE SEGURIDAD: Mostrar bot√≥n de alerta ---
        btnClientAlert.classList.remove('d-none');
      } else {
        try { document.body.classList.remove('ride-mode'); } catch {}
        btnClientAlert.classList.add('d-none');
      }

      if ((isAssigned || isArrived || isOnTrip) && currentAssignedDriverId) {
        driverNameEl.textContent = currentAssignedDriverId;
        arrivedDriverName.textContent = currentAssignedDriverId;
        // Show ETA in banner if available
        if (ride.etaSec != null && ride.etaSec > 0) {
          const mins = Math.max(1, Math.round(ride.etaSec / 60));
          etaInfo.textContent = `Est√° a ${mins} min de vos.`;
          try { navPillText.innerHTML = `<i class="bi bi-person-fill me-1"></i>${currentAssignedDriverId} ¬∑ <i class=\"bi bi-clock\" style=\"margin:0 .25rem 0 .35rem\"></i>${mins} min`; navPill.classList.remove('d-none'); } catch {}
        } else if (ride.status === 'arrived') {
          etaInfo.textContent = 'Ya lleg√≥ a tu ubicaci√≥n.';
          try { navPillText.innerHTML = `<i class="bi bi-person-fill me-1"></i>${currentAssignedDriverId} ¬∑ Lleg√≥`; navPill.classList.remove('d-none'); } catch {}
        } else if (ride.status === 'ontrip') {
          etaInfo.textContent = 'Viaje en curso.';
          try { navPillText.innerHTML = `<i class="bi bi-person-fill me-1"></i>${currentAssignedDriverId} ¬∑ En viaje`; navPill.classList.remove('d-none'); } catch {}
        } else {
          etaInfo.textContent = 'Siguiendo en tiempo real...';
          try { navPillText.innerHTML = `<i class="bi bi-person-fill me-1"></i>${currentAssignedDriverId}`; navPill.classList.remove('d-none'); } catch {}
        }
        // Immediate map focus
        try {
          const pts = [];
          if (lastDriverLatLng) pts.push(L.latLng(lastDriverLatLng));
          if (pickupMarker) pts.push(pickupMarker.getLatLng());
          if (destMarker && isOnTrip) pts.push(destMarker.getLatLng());
          if (pts.length >= 1) {
            if (pts.length === 1) map.flyTo(pts[0], 15, { animate: true, duration: 1 });
            else map.fitBounds(L.latLngBounds(pts).pad(0.2));
          }
          window.scrollTo({ top: 0, behavior: 'smooth' });
        } catch {}
      }
      else {
        // Hide pill outside ride navigation
        try { navPill.classList.add('d-none'); } catch {}
      }
      
      // üéØ Redirigir a rating cuando se completa
      if (isCompleted) {
        // Esperar 2 segundos y redirigir
        setTimeout(() => {
          window.location.href = `/rating.html?rideId=${rideId}&amount=850`;
        }, 2000);
        
        // Mostrar mensaje de transici√≥n
        fareAmount.textContent = '850';
        completedOverlay.classList.remove('d-none');
        waitingBanner.classList.add('d-none');
        assignedBanner.classList.add('d-none');
        arrivedBanner.classList.add('d-none');
      }
    }

    socket.on('driver_status', ({ online }) => {
      if (online) {
        driverStatus.textContent = 'online';
        driverStatus.className = 'badge text-bg-success';
      } else {
        driverStatus.textContent = 'offline';
        driverStatus.className = 'badge text-bg-secondary';
      }
    });

    // Own location handling
    function startMyLocation() {
      if (!('geolocation' in navigator)) { alert('Geolocalizaci√≥n no soportada'); return; }
      if (meWatchId != null) return;
      
      // üéØ FIX: √çcono personalizado GRANDE y VISIBLE para "Tu ubicaci√≥n"
      const myIcon = L.divIcon({ 
        className: '', 
        html: `<div style="position:relative;">
          <div style="background:#0dcaf0;border:4px solid #fff;border-radius:50%;width:32px;height:32px;box-shadow:0 0 15px rgba(13,202,240,0.8);"></div>
          <div style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:18px;">üìç</div>
        </div>`, 
        iconSize: [32, 32], 
        iconAnchor: [16, 16] 
      });
      
      meWatchId = navigator.geolocation.watchPosition(pos => {
        const { latitude: lat, longitude: lng, accuracy } = pos.coords;
        const latlng = [lat, lng];
        
        if (!meMarker) {
          meMarker = L.marker(latlng, { icon: myIcon, title:'Tu ubicaci√≥n', zIndexOffset: 1000 }).addTo(map);
        } else {
          meMarker.setLatLng(latlng);
        }
        
        const r = Math.min(accuracy||0, 200);
        if (!meCircle) {
          meCircle = L.circle(latlng, { 
            radius: r, 
            color:'#0dcaf0', 
            fillColor:'#0dcaf0', 
            fillOpacity:.2,
            weight: 2
          }).addTo(map);
        } else { 
          meCircle.setLatLng(latlng); 
          meCircle.setRadius(r); 
        }
      }, err => {
        console.warn('MyLocation error', err);
        alert('No se pudo obtener tu ubicaci√≥n');
      }, { enableHighAccuracy: true, maximumAge: 1000, timeout: 15000 });
    }
    myLocBtn.addEventListener('click', () => startMyLocation());

    // Client push subscription (optional)
    function urlBase64ToUint8Array(base64String) {
      const padding = '='.repeat((4 - base64String.length % 4) % 4);
      const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');
      const rawData = atob(base64); const outputArray = new Uint8Array(rawData.length);
      for (let i = 0; i < rawData.length; ++i) outputArray[i] = rawData.charCodeAt(i);
      return outputArray;
    }
    async function subscribeClientPush(silent = false) {
      try {
        if (!('serviceWorker' in navigator) || !('PushManager' in window)) { if (!silent) alert('Push no disponible'); return; }
        const reg = await navigator.serviceWorker.ready;
        const pub = await fetch('/api/push/publicKey').then(r=>r.json());
        if (!pub.publicKey) { if (!silent) alert('Push desactivado en servidor'); return; }
        const sub = await reg.pushManager.subscribe({ userVisibleOnly: true, applicationServerKey: urlBase64ToUint8Array(pub.publicKey) });
        await fetch('/api/push/subscribe', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ subscription: sub }) });
        enableClientPush.classList.add('d-none');
        if (!silent) alert('Notificaciones del viaje habilitadas');
      } catch { if (!silent) alert('No se pudo habilitar push'); }
    }
    // Hide notifications button if permission denied
    try { if (Notification.permission === 'denied') enableClientPush.classList.add('d-none'); } catch {}

    enableClientPush.addEventListener('click', async () => {
      const perm = await Notification.requestPermission();
      if (perm !== 'granted') return;
      subscribeClientPush();
    });

    // --- NUEVA FUNCI√ìN DE SEGURIDAD: Bot√≥n de alerta cliente ---
    btnClientAlert.addEventListener('click', () => {
      if (!rideId) { alert('No ten√©s un viaje activo'); return; }
      const desc = prompt('¬øQu√© situaci√≥n est√°s reportando? (opcional):');
      socket.emit('suspicious_activity', {
        rideId,
        type: 'passenger_suspicious',
        description: desc || 'Cliente report√≥ situaci√≥n sospechosa'
      });
      alert('üö® Alerta enviada. Despacho y contactos de emergencia fueron notificados.');
    });

    // --- NUEVA FUNCI√ìN DE SEGURIDAD: Escuchar alertas ---
    socket.on('suspicious_activity', (alert) => {
      try {
        const div = document.createElement('div');
        div.className = 'position-fixed top-0 start-50 translate-middle-x p-3';
        div.style.zIndex = 2200;
        div.innerHTML = `<div class="alert alert-danger alert-dismissible fade show shadow-lg" role="alert" style="min-width: 320px; max-width: 95vw;">
          <h5 class="alert-heading"><i class="bi bi-shield-exclamation me-2"></i>üö® ALERTA DE SEGURIDAD</h5>
          <p class="mb-1"><strong>Tipo:</strong> ${alert.type}</p>
          <p class="mb-1"><strong>Viaje:</strong> ${alert.rideId}</p>
          ${alert.description ? `<p class="mb-1"><small>${alert.description}</small></p>` : ''}
          <p class="mb-0 text-secondary"><small>Despacho y autoridades fueron notificados</small></p>
          <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
        </div>`;
        document.body.appendChild(div);
        try { navigator.vibrate?.([600,300,600,300,600]); } catch {}
        setTimeout(()=> div.remove(), 20000);
      } catch {}
    });

    // --- NUEVA FUNCI√ìN DE SEGURIDAD: Calcular ETA din√°mico ---
    async function updateETA() {
      if (!rideId || !lastDriverLatLng) return;
      const now = Date.now();
      if (now - lastEtaUpdate < 15000) return; // Throttle a cada 15s
      lastEtaUpdate = now;
      
      try {
        const driverPos = { lat: lastDriverLatLng[0], lng: lastDriverLatLng[1] };
        let targetCoord = null;
        
        // Decidir destino seg√∫n fase del viaje
        if (currentRideStatus === 'arriving' || currentRideStatus === 'assigned') {
          targetCoord = currentPickupCoord; // Yendo a recoger
        } else if (currentRideStatus === 'ontrip') {
          targetCoord = currentDestCoord; // Yendo a destino
        }
        
        if (!targetCoord || !isFinite(targetCoord.lat) || !isFinite(targetCoord.lng)) return;
        
        const q = `from=${driverPos.lat},${driverPos.lng}&to=${targetCoord.lat},${targetCoord.lng}`;
        const r = await fetch(`/api/route?${q}`);
        const j = await r.json();
        
        if (j.ok && j.etaMin) {
          lastEtaSec = j.etaMin * 60;
          etaBadge.style.display = 'inline-block';
          etaBadge.innerHTML = `<i class="bi bi-clock"></i> ETA: ${j.etaMin} min`;
          
          // Actualizar pill tambi√©n
          if (currentAssignedDriverId) {
            navPillText.innerHTML = `<i class="bi bi-person-fill me-1"></i>${currentAssignedDriverId} ¬∑ <i class="bi bi-clock" style="margin:0 .25rem 0 .35rem"></i>${j.etaMin} min`;
          }
        }
      } catch (e) {
        console.warn('ETA update failed', e);
      }
    }

    // Driver location stream
    socket.on('location', ({ lat, lng, accuracy, heading }) => {
      const latlng = [lat, lng];
      lastDriverLatLng = latlng;
      // --- NUEVA FUNCI√ìN DE SEGURIDAD: Actualizar ETA autom√°ticamente ---
      if (rideId && currentAssignedDriverId) {
        updateETA();
      }
      if (!marker) {
        marker = L.marker(latlng, { icon: arrowIcon }).addTo(map);
      } else {
        marker.setLatLng(latlng);
      }
      if (marker && marker._icon && heading != null) {
        marker._icon.style.transform = `rotate(${heading}deg)`;
        marker._icon.style.transformOrigin = '10px 10px';
      }
      const cap = Math.max(0, Number(accCapInput.value || 0));
      const radius = Math.max(accuracy || 0, 0);
      const visual = cap > 0 ? Math.min(radius, cap) : radius;
      if (!circle) {
        circle = L.circle(latlng, { radius: visual, color: '#0d6efd', fillColor: '#0d6efd', fillOpacity: 0.15 }).addTo(map);
      } else {
        circle.setLatLng(latlng);
        circle.setRadius(visual);
      }

      if (showTrail.checked) {
        const points = path.getLatLngs(); points.push(L.latLng(latlng));
        let maxPts = Math.max(10, Number(maxPtsInput.value || 200));
        while (points.length > maxPts) points.shift();
        path.setLatLngs(points); path.setStyle({ opacity: 0.9 });
      } else { path.setStyle({ opacity: 0 }); }

      centerBtn.disabled = false;

      // If assigned and we have pickup, fit once when first driver location arrives
      if (currentAssignedDriverId && pickupMarker && !map.__fittedAssignedOnce) {
        const pts = [pickupMarker.getLatLng(), L.latLng(latlng)];
        map.fitBounds(L.latLngBounds(pts).pad(0.2));
        map.__fittedAssignedOnce = true;
      }
    });

    function startDriversPolling() {
      if (driversPoll) return;
      const render = (list=[]) => {
        driversLayer.clearLayers();
        list.forEach(d => {
          if (!isFinite(d.lat)||!isFinite(d.lng)) return;
          L.circleMarker([d.lat, d.lng], { radius: 5, color:'#0d6efd', fillColor:'#0d6efd', fillOpacity:0.8 }).addTo(driversLayer);
        });
        driversCount.textContent = `${list.length} chofer${list.length===1?'':'es'} cerca`;
      };
      const tick = async () => {
        try {
          const r = await fetch('/api/drivers');
          const j = await r.json();
          if (j?.ok && Array.isArray(j.drivers)) render(j.drivers);
        } catch {}
      };
      tick();
      driversPoll = setInterval(tick, 5000);
    }
    function stopDriversPolling() { if (driversPoll) { clearInterval(driversPoll); driversPoll=null; } driversLayer.clearLayers(); }

    // Ride-level updates (status/eta/location)
    socket.on('ride_update', (msg) => {
      if (!rideId) return;
      if (msg.type === 'status') {
        updateRideUi({ status: msg.status, etaSec: msg.etaSec });
        // Fit per phase
        if (msg.status === 'ontrip' && lastDriverLatLng && destMarker) {
          const pts = [L.latLng(lastDriverLatLng), destMarker.getLatLng()];
          map.fitBounds(L.latLngBounds(pts).pad(0.2));
        }
        // Poll drivers only while waiting
        if (msg.status === 'requested' && !currentAssignedDriverId) { if (!driversPoll) startDriversPolling(); }
        else { stopDriversPolling(); }
      } else if (msg.type === 'assigned') {
        if (msg.driverId) {
          currentAssignedDriverId = msg.driverId;
          localStorage.setItem('driverId', msg.driverId);
          joinedRoom = msg.driverId;
          socket.emit('join', { role: 'client', driverId: msg.driverId });
          // Stop showing all drivers, focus on this ride
          stopDriversPolling();
          map.__fittedAssignedOnce = false;
          // Hide waiting banner immediately and show assigned
          updateRideUi({ status: 'assigned', etaSec: null });
          // Local feedback
          playAssignedBeep();
          // Auto-start client location to show where they are
          setTimeout(() => { try { startMyLocation(); } catch {} }, 500);
          // Auto-request push notifications (silent mode)
          setTimeout(() => { try { if (Notification.permission === 'default') subscribeClientPush(true); } catch {} }, 1000);
          // If driver already has location, zoom to it
          setTimeout(() => {
            if (lastDriverLatLng) {
              const pts = pickupMarker ? [pickupMarker.getLatLng(), L.latLng(lastDriverLatLng)] : [L.latLng(lastDriverLatLng)];
              map.fitBounds(L.latLngBounds(pts).pad(0.2));
            }
          }, 1500);
        }
      } else if (msg.type === 'route') {
        updateRouteUi(msg.pickupCoord, msg.destCoord);
      }
    });

    // Unified ride updates
    // (The assigned/route handling above remains; status handling unified here)
    socket.off?.('ride_update');
    socket.on('ride_update', (msg) => {
      if (!rideId) return;
      if (msg.type === 'status') {
        const temp = { status: msg.status, etaSec: msg.etaSec };
        currentRideStatus = msg.status; // üéØ Actualizar estado actual
        updateRideUi(temp);
        
        // üéØ ETAPA 3: Cuando marca "Llegu√©", cambiar foco a ruta pickup ‚Üí destino
        if (msg.status === 'arrived') {
          playArrivedBeep();
          console.log('‚úÖ Conductor lleg√≥ al pickup. Cambiando mapa a ruta pickup ‚Üí destino');
          
          // Ajustar mapa para mostrar pickup ‚Üí destino
          const pts = [];
          if (pickupMarker) pts.push(pickupMarker.getLatLng());
          if (destMarker) pts.push(destMarker.getLatLng());
          if (marker) pts.push(marker.getLatLng()); // Incluir conductor tambi√©n
          
          if (pts.length >= 2) {
            try {
              map.fitBounds(L.latLngBounds(pts).pad(0.3), { animate: true, duration: 1 });
            } catch {}
          }
        }
        
        // üéØ ETAPA 3: Cuando empieza viaje al destino
        if (msg.status === 'ontrip') {
          console.log('‚úÖ Conductor en camino al destino');
          // El autoFit ya maneja esto autom√°ticamente
        }
      } else if (msg.type === 'assigned') {
        if (msg.driverId) {
          currentAssignedDriverId = msg.driverId;
          localStorage.setItem('driverId', msg.driverId);
          joinedRoom = msg.driverId;
          socket.emit('join', { role: 'client', driverId: msg.driverId });
          stopDriversPolling();
          map.__fittedAssignedOnce = false;
          updateRideUi({ status: 'assigned', etaSec: null });
          playAssignedBeep();
          
          // üéØ FIX: Notificaci√≥n visual GRANDE cuando el conductor acepta
          const notifDiv = document.createElement('div');
          notifDiv.className = 'position-fixed top-50 start-50 translate-middle';
          notifDiv.style.zIndex = '3000';
          notifDiv.innerHTML = `
            <div class="card shadow-lg border-success border-4" style="min-width: 360px; max-width: 90vw; animation: pulse 0.5s;">
              <div class="card-header bg-success text-white text-center">
                <h4 class="mb-0"><i class="bi bi-check-circle-fill me-2"></i>¬°Conductor Asignado!</h4>
              </div>
              <div class="card-body text-center">
                <div class="display-4 mb-3">üöï</div>
                <p class="fs-5 mb-2">Tu conductor est√° en camino</p>
                <p class="text-secondary mb-1"><strong>Conductor:</strong> <span id="driverNameSpan">${msg.driverId}</span></p>
                <p class="text-secondary small mb-3">Verificando ubicaci√≥n...</p>
                <button class="btn btn-success btn-lg" onclick="this.closest('div[style*=\\'z-index\\']').remove()">
                  <i class="bi bi-map me-1"></i> Ver en mapa
                </button>
              </div>
            </div>
          `;
          document.body.appendChild(notifDiv);
          
          // üéØ FIX: Obtener info del conductor
          (async () => {
            try {
              const driverRes = await fetch(`/api/drivers/${encodeURIComponent(msg.driverId)}`);
              if (driverRes.ok) {
                const driver = await driverRes.json();
                const nameSpan = document.getElementById('driverNameSpan');
                if (nameSpan && driver.name) {
                  nameSpan.textContent = `${driver.name} (${msg.driverId})`;
                }
              }
            } catch {}
          })();
          
          // Auto-cerrar despu√©s de 6 segundos
          setTimeout(() => {
            try { notifDiv.remove(); } catch {}
          }, 6000);
          
          // Vibrar
          try { navigator.vibrate?.([200,100,200,100,200]); } catch {}
          
          // üéØ FIX: Dejar de mostrar taxis disponibles
          stopShowingNearbyDrivers();
          
          // üéØ ETAPA 2: Iniciar zoom autom√°tico
          startAutoFit();
          
          // üéØ MEJORA 1: Fetch inmediato de ubicaci√≥n del conductor
          (async () => {
            try {
              const lr = await fetch(`/api/lastLocation?driverId=${encodeURIComponent(msg.driverId)}`);
              if (lr.ok) {
                const loc = await lr.json();
                if (loc && isFinite(loc.lat) && isFinite(loc.lng)) {
                  lastDriverLatLng = [loc.lat, loc.lng];
                  const latlng = lastDriverLatLng;
                  
                  // Mostrar marcador inmediatamente
                  if (!marker) marker = L.marker(latlng, { icon: arrowIcon }).addTo(map); 
                  else marker.setLatLng(latlng);
                  
                  const visual = Math.min(loc.accuracy||0, Math.max(0, Number(accCapInput.value||150)));
                  if (!circle) circle = L.circle(latlng, { radius: visual, color:'#0d6efd', fillColor:'#0d6efd', fillOpacity:0.15 }).addTo(map);
                  else { circle.setLatLng(latlng); circle.setRadius(visual); }
                  
                  // üéØ MEJORA 2: Fit bounds con conductor + pickup + mi ubicaci√≥n
                  const pts = [];
                  if (pickupMarker) pts.push(pickupMarker.getLatLng());
                  if (destMarker) pts.push(destMarker.getLatLng());
                  pts.push(L.latLng(latlng));
                  
                  // üéØ FIX: Agregar mi ubicaci√≥n actual si la tengo
                  if (meMarker) pts.push(meMarker.getLatLng());
                  
                  if (pts.length) {
                    try { 
                      const bounds = L.latLngBounds(pts);
                      map.fitBounds(bounds.pad(0.35), { 
                        animate: true, 
                        duration: 0.8,
                        maxZoom: 15  // No hacer zoom demasiado cercano
                      }); 
                      map.__fittedAssignedOnce = true;
                      
                      // üéØ FIX: Mostrar info visual de distancia
                      if (pickupMarker) {
                        const dist = map.distance(latlng, pickupMarker.getLatLng());
                        const km = (dist / 1000).toFixed(1);
                        console.log(`Conductor est√° a ${km} km del pickup`);
                      }
                    } catch (e) {
                      console.error('Error fitting bounds', e);
                    } 
                  }
                }
              }
            } catch (e) {
              console.warn('No se pudo obtener ubicaci√≥n inicial del conductor', e);
            }
          })();
          
          setTimeout(() => { try { startMyLocation(); } catch {} }, 500);
          setTimeout(() => { try { if (Notification.permission === 'default') subscribeClientPush(true); } catch {} }, 1000);
        }
      } else if (msg.type === 'route') {
        updateRouteUi(msg.pickupCoord, msg.destCoord);
      }
    });

    async function updateRouteUi(pickupCoord, destCoord) {
      // --- NUEVA FUNCI√ìN DE SEGURIDAD: Guardar coords actuales ---
      if (pickupCoord) {
        currentPickupCoord = pickupCoord;
        const latlng = [pickupCoord.lat, pickupCoord.lng];
        
        // üéØ FIX: √çcono verde grande para pickup
        const pickupIcon = L.divIcon({ 
          className: '', 
          html: '<div style="background:#28a745;border:4px solid #fff;border-radius:50%;width:28px;height:28px;box-shadow:0 2px 10px rgba(40,167,69,0.6);"></div>', 
          iconSize: [28, 28], 
          iconAnchor: [14, 14] 
        });
        
        if (!pickupMarker) pickupMarker = L.marker(latlng, { icon: pickupIcon, title: 'Tu ubicaci√≥n de partida', zIndexOffset: 500 }).addTo(map); 
        else { pickupMarker.setLatLng(latlng); pickupMarker.setIcon(pickupIcon); }
      }
      if (destCoord) {
        currentDestCoord = destCoord;
        const latlng = [destCoord.lat, destCoord.lng];
        
        // üéØ FIX: √çcono rojo para destino
        const destIcon = L.divIcon({ 
          className: '', 
          html: '<div style="background:#dc3545;border:4px solid #fff;border-radius:50%;width:24px;height:24px;box-shadow:0 2px 8px rgba(220,53,69,0.5);"></div>', 
          iconSize: [24, 24], 
          iconAnchor: [12, 12] 
        });
        
        if (!destMarker) destMarker = L.marker(latlng, { icon: destIcon, title: 'Destino', zIndexOffset: 400 }).addTo(map); 
        else { destMarker.setLatLng(latlng); destMarker.setIcon(destIcon); }
      }
      if (pickupCoord && destCoord) {
        try {
          const q = `from=${pickupCoord.lat},${pickupCoord.lng}&to=${destCoord.lat},${destCoord.lng}`;
          const r = await fetch(`/api/route?${q}`);
          const j = await r.json();
          const line = (j.ok && Array.isArray(j.line) && j.line.length) ? j.line : [pickupCoord, destCoord];
          routeLine.setLatLngs(line.map(p=>[p.lat,p.lng]));
          const b = L.latLngBounds(line.map(p=>[p.lat,p.lng]));
          map.fitBounds(b.pad(0.2));
        } catch (e) {
          routeLine.setLatLngs([[pickupCoord.lat, pickupCoord.lng], [destCoord.lat, destCoord.lng]]);
          const b = L.latLngBounds([[pickupCoord.lat, pickupCoord.lng], [destCoord.lat, destCoord.lng]]);
          map.fitBounds(b.pad(0.2));
        }
      }
    }

    // üéØ ETAPA 2: Timer para re-ajustar zoom autom√°tico
    let autoFitInterval = null;
    
    function startAutoFit() {
      stopAutoFit();
      autoFitInterval = setInterval(() => {
        // üéØ ETAPA 2: Re-ajustar zoom para mostrar conductor + pickup (o destino si va en camino)
        const pts = [];
        
        // Agregar conductor si existe
        if (marker) pts.push(marker.getLatLng());
        
        // Agregar pickup o destino seg√∫n fase
        if (currentRideStatus === 'assigned' || currentRideStatus === 'arriving' || currentRideStatus === 'arrived') {
          // Yendo al pickup
          if (pickupMarker) pts.push(pickupMarker.getLatLng());
        } else if (currentRideStatus === 'ontrip') {
          // Yendo al destino
          if (destMarker) pts.push(destMarker.getLatLng());
        }
        
        // Agregar mi ubicaci√≥n si la tengo
        if (meMarker) pts.push(meMarker.getLatLng());
        
        if (pts.length >= 2) {
          try {
            map.fitBounds(L.latLngBounds(pts).pad(0.3), { animate: true, duration: 0.5 });
          } catch {}
        }
      }, 15000); // Cada 15 segundos
    }
    
    function stopAutoFit() {
      if (autoFitInterval) {
        clearInterval(autoFitInterval);
        autoFitInterval = null;
      }
    }

    async function updateLocation(latlng) {
      const cap = Number(accCapInput.value || 150);
      const visual = cap > 0 ? Math.min(radius, cap) : radius;
      if (!circle) {
        circle = L.circle(latlng, { radius: visual, color: '#0d6efd', fillColor: '#0d6efd', fillOpacity: 0.15 }).addTo(map);
      } else {
        circle.setLatLng(latlng);
        circle.setRadius(visual);
      }

      // trail with max points
      if (showTrail.checked) {
        const points = path.getLatLngs();
        points.push(L.latLng(latlng));
        let maxPts = Math.max(10, Number(maxPtsInput.value || 200));
        while (points.length > maxPts) points.shift();
        path.setLatLngs(points);
        path.setStyle({ opacity: 0.9 });
      } else {
        path.setStyle({ opacity: 0 });
      }

      centerBtn.disabled = false;
    }

    connectBtn.addEventListener('click', () => { joinAsClient(); });
    clearTrailBtn.addEventListener('click', () => { path.setLatLngs([]); });
    centerBtn.addEventListener('click', () => {
      if (!marker) return;
      const latlng = marker.getLatLng();
      if (map.getZoom() < 15) map.setZoom(15);
      map.panTo(latlng, { animate: true });
    });

    // üí¨ CHAT FUNCTIONALITY
    const chatWidget = document.getElementById('chatWidget');
    const chatToggle = document.getElementById('chatToggle');
    const chatBox = document.getElementById('chatBox');
    const chatMessages = document.getElementById('chatMessages');
    const chatInput = document.getElementById('chatInput');
    const chatSend = document.getElementById('chatSend');
    
    // Toggle chat
    chatToggle?.addEventListener('click', () => {
      const isVisible = chatBox.style.display !== 'none';
      chatBox.style.display = isVisible ? 'none' : 'block';
    });
    
    // Send message
    function sendChatMessage() {
      const msg = chatInput.value.trim();
      if (!msg || !rideId) return;
      
      socket.emit('chat_message', { rideId, message: msg, from: 'client' });
      addChatMessage(msg, 'client');
      chatInput.value = '';
    }
    
    chatSend?.addEventListener('click', sendChatMessage);
    chatInput?.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') sendChatMessage();
    });
    
    // Add message to chat
    function addChatMessage(text, from) {
      const div = document.createElement('div');
      div.style.marginBottom = '12px';
      div.style.textAlign = from === 'client' ? 'right' : 'left';
      div.innerHTML = `
        <div style="display: inline-block; max-width: 70%; padding: 10px 14px; border-radius: 12px; background: ${from === 'client' ? '#10b981' : '#e5e7eb'}; color: ${from === 'client' ? '#fff' : '#000'}; font-size: 14px;">
          ${text}
        </div>
      `;
      chatMessages.appendChild(div);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }
    
    // Receive messages
    socket.on('chat_message', ({ message, from }) => {
      if (from !== 'client') {
        addChatMessage(message, 'driver');
        // Notificaci√≥n de sonido
        try {
          const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBCl+zO/aizsIHmm98OKdTgwOUKrj7bVkHAU2jdbxynkqBSh+zPDcjz8LElyw5vCoWRUIQ5zc8MBsIAQnfMvv3Io6Bx1puvDinE0MEE+n4+2zZBwGM4zU8Ml5KQUJ');
          audio.play();
        } catch {}
      }
    });
    
    // Show chat when ride is assigned
    if (rideId) {
      chatWidget.style.display = 'block';
    }
    
    // üó∫Ô∏è COMPARTIR VIAJE
    const shareRideBtn = document.getElementById('shareRideBtn');
    shareRideBtn?.addEventListener('click', async () => {
      const shareUrl = `${window.location.origin}/client.html?rideId=${rideId}`;
      const shareText = 'üöï Segu√≠ mi viaje en tiempo real';
      
      // Intentar usar Web Share API
      if (navigator.share) {
        try {
          await navigator.share({
            title: 'TuRemis - Seguimiento en vivo',
            text: shareText,
            url: shareUrl
          });
        } catch (err) {
          if (err.name !== 'AbortError') {
            copyToClipboard(shareUrl);
          }
        }
      } else {
        // Fallback: copiar al portapapeles
        copyToClipboard(shareUrl);
      }
    });
    
    function copyToClipboard(text) {
      if (navigator.clipboard) {
        navigator.clipboard.writeText(text).then(() => {
          alert('‚úÖ Link copiado al portapapeles!\n\nCompartilo para que te sigan en tiempo real.');
        });
      } else {
        // Fallback antiguo
        const textarea = document.createElement('textarea');
        textarea.value = text;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand('copy');
        document.body.removeChild(textarea);
        alert('‚úÖ Link copiado!\n\n' + text);
      }
    }
    
    // auto-connect on load
    window.addEventListener('load', () => { joinAsClient(); });
    // Hide advanced controls on ride mode
    if (rideId) {
      document.querySelectorAll('.adv').forEach(el => el.style.display = 'none');
      if (driverGroup) driverGroup.style.display = 'none';
      if (connectBtn) connectBtn.style.display = 'none';
      // Start polling only while waiting; initial fetch to decide
      (async () => {
        try {
          const r = await fetch(`/api/rides/${rideId}`);
          const ride = r.ok ? await r.json() : null;
          const waiting = ride && ride.status === 'requested' && !ride.driverId;
          if (waiting) startDriversPolling(); else stopDriversPolling();
          // If we already have a driver assigned on reload, join rooms and draw last known location immediately
          if (ride && ride.driverId) {
            currentAssignedDriverId = ride.driverId;
            localStorage.setItem('driverId', ride.driverId);
            joinedRoom = ride.driverId;
            socket.emit('join', { role: 'client', driverId: ride.driverId });
            socket.emit('join_ride', { rideId });
            // Render route markers if present
            try { updateRouteUi(ride.pickupCoord, ride.destCoord); } catch {}
            // Fetch last known driver location and render instantly
            try {
              const lr = await fetch(`/api/lastLocation?driverId=${encodeURIComponent(ride.driverId)}`);
              if (lr.ok) {
                const loc = await lr.json();
                if (loc && isFinite(loc.lat) && isFinite(loc.lng)) {
                  lastDriverLatLng = [loc.lat, loc.lng];
                  const latlng = lastDriverLatLng;
                  if (!marker) marker = L.marker(latlng, { icon: arrowIcon }).addTo(map); else marker.setLatLng(latlng);
                  const visual = Math.min(loc.accuracy||0, Math.max(0, Number(accCapInput.value||150)));
                  if (!circle) circle = L.circle(latlng, { radius: visual, color:'#0d6efd', fillColor:'#0d6efd', fillOpacity:0.15 }).addTo(map);
                  else { circle.setLatLng(latlng); circle.setRadius(visual); }
                  // Fit bounds quickly to show context
                  const pts = [];
                  if (pickupMarker) pts.push(pickupMarker.getLatLng());
                  pts.push(L.latLng(latlng));
                  if (ride.status === 'ontrip' && destMarker) pts.push(destMarker.getLatLng());
                  if (pts.length) { try { map.fitBounds(L.latLngBounds(pts).pad(0.2)); } catch {} }
                  // Update UI/pill for assigned state
                  updateRideUi({ status: ride.status || 'assigned', etaSec: ride.etaSec ?? null });
                }
              }
            } catch {}
          }
          // Auto-start client GPS on ride mode
          setTimeout(() => { try { startMyLocation(); } catch {} }, 800);
          // Auto-request push notifications on ride mode (silent)
          setTimeout(async () => {
            try {
              if (Notification.permission === 'default') {
                const perm = await Notification.requestPermission();
                if (perm === 'granted') subscribeClientPush(true);
              } else if (Notification.permission === 'granted') {
                subscribeClientPush(true);
              }
            } catch {}
          }, 1500);
        } catch { startDriversPolling(); }
      })();
    }
  </script>
</body>
</html>
